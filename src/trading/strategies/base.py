"""
Base Strategy Module

Provides abstract base class for all trading strategies with signal generation
and position management interfaces.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

import numpy as np
import pandas as pd


class SignalType(Enum):
    """Trading signal types."""

    BUY = 1
    SELL = -1
    HOLD = 0


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        symbol: Ticker symbol for the signal.
        signal_type: Type of signal (BUY, SELL, HOLD).
        strength: Signal strength between -1.0 and 1.0.
        timestamp: Time when the signal was generated.
        price: Current price at signal generation.
        metadata: Additional signal metadata (indicators, etc.).
    """

    symbol: str
    signal_type: SignalType
    strength: float
    timestamp: datetime
    price: float
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate signal strength is within bounds."""
        if not -1.0 <= self.strength <= 1.0:
            raise ValueError(f"Signal strength must be between -1.0 and 1.0, got {self.strength}")

    @property
    def is_buy(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type == SignalType.BUY

    @property
    def is_sell(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type == SignalType.SELL

    @property
    def is_hold(self) -> bool:
        """Check if this is a hold signal."""
        return self.signal_type == SignalType.HOLD


@dataclass
class Position:
    """
    Represents a trading position.

    Attributes:
        symbol: Ticker symbol.
        quantity: Number of shares (positive for long, negative for short).
        entry_price: Average entry price.
        entry_time: Time when position was opened.
        current_price: Current market price.
        stop_loss: Stop loss price (optional).
        take_profit: Take profit price (optional).
    """

    symbol: str
    quantity: float
    entry_price: float
    entry_time: datetime
    current_price: float | None = None
    stop_loss: float | None = None
    take_profit: float | None = None

    @property
    def is_long(self) -> bool:
        """Check if position is long."""
        return self.quantity > 0

    @property
    def is_short(self) -> bool:
        """Check if position is short."""
        return self.quantity < 0

    @property
    def market_value(self) -> float:
        """Calculate current market value of position."""
        price = self.current_price or self.entry_price
        return abs(self.quantity) * price

    @property
    def cost_basis(self) -> float:
        """Calculate cost basis of position."""
        return abs(self.quantity) * self.entry_price

    @property
    def unrealized_pnl(self) -> float:
        """Calculate unrealized profit/loss."""
        if self.current_price is None:
            return 0.0
        price_diff = self.current_price - self.entry_price
        return self.quantity * price_diff

    @property
    def unrealized_pnl_pct(self) -> float:
        """Calculate unrealized profit/loss as percentage."""
        if self.cost_basis == 0:
            return 0.0
        return self.unrealized_pnl / self.cost_basis * 100

    def should_stop_loss(self) -> bool:
        """Check if stop loss should be triggered."""
        if self.stop_loss is None or self.current_price is None:
            return False

        if self.is_long:
            return self.current_price <= self.stop_loss
        else:
            return self.current_price >= self.stop_loss

    def should_take_profit(self) -> bool:
        """Check if take profit should be triggered."""
        if self.take_profit is None or self.current_price is None:
            return False

        if self.is_long:
            return self.current_price >= self.take_profit
        else:
            return self.current_price <= self.take_profit


@dataclass
class StrategyConfig:
    """
    Base configuration for trading strategies.

    Attributes:
        name: Strategy name.
        lookback_period: Number of periods to look back for calculations.
        min_data_points: Minimum data points required for signal generation.
        risk_per_trade: Maximum risk per trade as fraction of capital.
    """

    name: str = "BaseStrategy"
    lookback_period: int = 20
    min_data_points: int = 50
    risk_per_trade: float = 0.02


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    All trading strategies should inherit from this class and implement
    the abstract methods for signal generation and position management.

    Example:
        >>> class MyStrategy(BaseStrategy):
        ...     def generate_signals(self, data: pd.DataFrame) -> list[Signal]:
        ...         # Implement signal generation logic
        ...         pass
        ...
        ...     def calculate_position_size(
        ...         self, signal: Signal, capital: float, risk: float
        ...     ) -> float:
        ...         # Implement position sizing logic
        ...         pass
    """

    def __init__(self, config: StrategyConfig | None = None) -> None:
        """
        Initialize the strategy.

        Args:
            config: Strategy configuration. Defaults to base config.
        """
        self.config = config or StrategyConfig()
        self._positions: dict[str, Position] = {}
        self._signal_history: list[Signal] = []

    @property
    def name(self) -> str:
        """Get strategy name."""
        return self.config.name

    @property
    def positions(self) -> dict[str, Position]:
        """Get current positions."""
        return self._positions.copy()

    @property
    def signal_history(self) -> list[Signal]:
        """Get signal history."""
        return self._signal_history.copy()

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> list[Signal]:
        """
        Generate trading signals from market data.

        Args:
            data: DataFrame with OHLCV data. Expected columns:
                - datetime: Timestamp
                - open: Open price
                - high: High price
                - low: Low price
                - close: Close price
                - volume: Trading volume

        Returns:
            List of Signal objects for the current period.
        """
        pass

    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        capital: float,
        risk_per_trade: float | None = None,
    ) -> float:
        """
        Calculate position size for a signal.

        Args:
            signal: Trading signal.
            capital: Available capital.
            risk_per_trade: Maximum risk per trade as fraction (overrides config).

        Returns:
            Number of shares to trade (positive for buy, negative for sell).
        """
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that data meets minimum requirements.

        Args:
            data: DataFrame with OHLCV data.

        Returns:
            True if data is valid, False otherwise.
        """
        required_columns = ["open", "high", "low", "close", "volume"]

        if data is None or data.empty:
            return False

        # Check for required columns (case-insensitive)
        data_columns_lower = [col.lower() for col in data.columns]
        for col in required_columns:
            if col not in data_columns_lower:
                return False

        # Check minimum data points
        if len(data) < self.config.min_data_points:
            return False

        return True

    def update_position(
        self,
        symbol: str,
        quantity: float,
        price: float,
        timestamp: datetime,
        stop_loss: float | None = None,
        take_profit: float | None = None,
    ) -> Position:
        """
        Update or create a position.

        Args:
            symbol: Ticker symbol.
            quantity: Number of shares (positive for buy, negative for sell).
            price: Execution price.
            timestamp: Execution time.
            stop_loss: Stop loss price (optional).
            take_profit: Take profit price (optional).

        Returns:
            Updated or new Position object.
        """
        if symbol in self._positions:
            existing = self._positions[symbol]
            new_quantity = existing.quantity + quantity

            if new_quantity == 0:
                # Position closed
                del self._positions[symbol]
                return Position(
                    symbol=symbol,
                    quantity=0,
                    entry_price=price,
                    entry_time=timestamp,
                    current_price=price,
                )

            # Calculate new average price
            if (existing.quantity > 0 and quantity > 0) or (
                existing.quantity < 0 and quantity < 0
            ):
                # Adding to position - calculate weighted average
                total_cost = (
                    abs(existing.quantity) * existing.entry_price
                    + abs(quantity) * price
                )
                new_avg_price = total_cost / abs(new_quantity)
            else:
                # Reducing position - keep original entry price
                new_avg_price = existing.entry_price

            position = Position(
                symbol=symbol,
                quantity=new_quantity,
                entry_price=new_avg_price,
                entry_time=existing.entry_time,
                current_price=price,
                stop_loss=stop_loss or existing.stop_loss,
                take_profit=take_profit or existing.take_profit,
            )
        else:
            # New position
            position = Position(
                symbol=symbol,
                quantity=quantity,
                entry_price=price,
                entry_time=timestamp,
                current_price=price,
                stop_loss=stop_loss,
                take_profit=take_profit,
            )

        if position.quantity != 0:
            self._positions[symbol] = position

        return position

    def close_position(self, symbol: str, price: float, timestamp: datetime) -> Position | None:
        """
        Close a position.

        Args:
            symbol: Ticker symbol.
            price: Closing price.
            timestamp: Closing time.

        Returns:
            Closed Position object or None if no position exists.
        """
        if symbol not in self._positions:
            return None

        position = self._positions[symbol]
        position.current_price = price
        closed_position = Position(
            symbol=symbol,
            quantity=0,
            entry_price=position.entry_price,
            entry_time=position.entry_time,
            current_price=price,
        )

        del self._positions[symbol]
        return closed_position

    def get_position(self, symbol: str) -> Position | None:
        """
        Get position for a symbol.

        Args:
            symbol: Ticker symbol.

        Returns:
            Position object or None if no position exists.
        """
        return self._positions.get(symbol)

    def has_position(self, symbol: str) -> bool:
        """
        Check if a position exists for a symbol.

        Args:
            symbol: Ticker symbol.

        Returns:
            True if position exists, False otherwise.
        """
        return symbol in self._positions

    def add_signal(self, signal: Signal) -> None:
        """
        Add a signal to history.

        Args:
            signal: Signal to add.
        """
        self._signal_history.append(signal)

    def clear_history(self) -> None:
        """Clear signal history."""
        self._signal_history.clear()

    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators for the data.

        Override this method in subclasses to add strategy-specific indicators.

        Args:
            data: DataFrame with OHLCV data.

        Returns:
            DataFrame with added indicator columns.
        """
        return data.copy()

    def __repr__(self) -> str:
        """String representation of the strategy."""
        return f"{self.__class__.__name__}(name={self.name!r})"


__all__ = [
    "BaseStrategy",
    "Signal",
    "SignalType",
    "Position",
    "StrategyConfig",
]
